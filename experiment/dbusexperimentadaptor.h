
/*
 *	This file was automatically generated by dbusxx-xml2cpp; DO NOT EDIT!
 */

#ifndef __dbusxx__dbusexperimentadaptor_h__ADAPTOR_MARSHAL_H
#define __dbusxx__dbusexperimentadaptor_h__ADAPTOR_MARSHAL_H

#include <dbus-c++/dbus.h>

namespace soma {
namespace recording {

class Experiment_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Experiment_adaptor()
    : ::DBus::InterfaceAdaptor("soma.recording.Experiment")
    {
        register_method(Experiment_adaptor, GetFileProperties, _GetFileProperties_stub);
        register_method(Experiment_adaptor, GetName, _GetName_stub);
        register_method(Experiment_adaptor, GetEpochs, _GetEpochs_stub);
        register_method(Experiment_adaptor, CreateEpoch, _CreateEpoch_stub);
        register_method(Experiment_adaptor, RenameEpoch, _RenameEpoch_stub);
        register_method(Experiment_adaptor, GetEpoch, _GetEpoch_stub);
        register_method(Experiment_adaptor, Close, _Close_stub);
    }

    ::DBus::IntrospectedInterface *const introspect() const 
    {
        static ::DBus::IntrospectedArgument GetFileProperties_args[] = 
        {
            { "props", "a{ss}", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument GetName_args[] = 
        {
            { "name", "s", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument GetEpochs_args[] = 
        {
            { "epochs", "ao", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument CreateEpoch_args[] = 
        {
            { "name", "s", true },
            { "epoch", "o", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument RenameEpoch_args[] = 
        {
            { "epoch", "o", true },
            { "newname", "s", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument GetEpoch_args[] = 
        {
            { "name", "s", true },
            { "epoch", "o", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument Close_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument EpochCreate_args[] = 
        {
            { "objpath", "o", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod Experiment_adaptor_methods[] = 
        {
            { "GetFileProperties", GetFileProperties_args },
            { "GetName", GetName_args },
            { "GetEpochs", GetEpochs_args },
            { "CreateEpoch", CreateEpoch_args },
            { "RenameEpoch", RenameEpoch_args },
            { "GetEpoch", GetEpoch_args },
            { "Close", Close_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Experiment_adaptor_signals[] = 
        {
            { "EpochCreate", EpochCreate_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Experiment_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Experiment_adaptor_interface = 
        {
            "soma.recording.Experiment",
            Experiment_adaptor_methods,
            Experiment_adaptor_signals,
            Experiment_adaptor_properties
        };
        return &Experiment_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual std::map< std::string, std::string > GetFileProperties() = 0;
    virtual std::string GetName() = 0;
    virtual std::vector< ::DBus::Path > GetEpochs() = 0;
    virtual ::DBus::Path CreateEpoch(const std::string& name) = 0;
    virtual void RenameEpoch(const ::DBus::Path& epoch, const std::string& newname) = 0;
    virtual ::DBus::Path GetEpoch(const std::string& name) = 0;
    virtual void Close() = 0;

public:

    /* signal emitters for this interface
     */
    void EpochCreate(const ::DBus::Path& arg1)
    {
        ::DBus::SignalMessage sig("EpochCreate");
        ::DBus::MessageIter wi = sig.writer();
        wi << arg1;
        emit_signal(sig);
    }

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _GetFileProperties_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::map< std::string, std::string > argout1 = GetFileProperties();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _GetName_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argout1 = GetName();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _GetEpochs_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::vector< ::DBus::Path > argout1 = GetEpochs();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _CreateEpoch_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        ::DBus::Path argout1 = CreateEpoch(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _RenameEpoch_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        ::DBus::Path argin1; ri >> argin1;
        std::string argin2; ri >> argin2;
        RenameEpoch(argin1, argin2);
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _GetEpoch_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::string argin1; ri >> argin1;
        ::DBus::Path argout1 = GetEpoch(argin1);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _Close_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        Close();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
};

} } 
namespace soma {
namespace recording {

class Timeline_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Timeline_adaptor()
    : ::DBus::InterfaceAdaptor("soma.recording.Timeline")
    {
        register_method(Timeline_adaptor, GetReferenceTime, _GetReferenceTime_stub);
        register_method(Timeline_adaptor, MarkReferenceTime, _MarkReferenceTime_stub);
    }

    ::DBus::IntrospectedInterface *const introspect() const 
    {
        static ::DBus::IntrospectedArgument GetReferenceTime_args[] = 
        {
            { "reftime", "t", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument MarkReferenceTime_args[] = 
        {
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument ReferenceTimeChange_args[] = 
        {
            { "time", "t", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod Timeline_adaptor_methods[] = 
        {
            { "GetReferenceTime", GetReferenceTime_args },
            { "MarkReferenceTime", MarkReferenceTime_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Timeline_adaptor_signals[] = 
        {
            { "ReferenceTimeChange", ReferenceTimeChange_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Timeline_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Timeline_adaptor_interface = 
        {
            "soma.recording.Timeline",
            Timeline_adaptor_methods,
            Timeline_adaptor_signals,
            Timeline_adaptor_properties
        };
        return &Timeline_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual uint64_t GetReferenceTime() = 0;
    virtual void MarkReferenceTime() = 0;

public:

    /* signal emitters for this interface
     */
    void ReferenceTimeChange(const uint64_t& arg1)
    {
        ::DBus::SignalMessage sig("ReferenceTimeChange");
        ::DBus::MessageIter wi = sig.writer();
        wi << arg1;
        emit_signal(sig);
    }

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _GetReferenceTime_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        uint64_t argout1 = GetReferenceTime();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _MarkReferenceTime_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        MarkReferenceTime();
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
};

} } 
namespace soma {
namespace recording {

class Notes_adaptor
: public ::DBus::InterfaceAdaptor
{
public:

    Notes_adaptor()
    : ::DBus::InterfaceAdaptor("soma.recording.Notes")
    {
        register_method(Notes_adaptor, CreateNote, _CreateNote_stub);
        register_method(Notes_adaptor, GetNote, _GetNote_stub);
        register_method(Notes_adaptor, SetNote, _SetNote_stub);
        register_method(Notes_adaptor, DeleteNote, _DeleteNote_stub);
        register_method(Notes_adaptor, GetNotes, _GetNotes_stub);
    }

    ::DBus::IntrospectedInterface *const introspect() const 
    {
        static ::DBus::IntrospectedArgument CreateNote_args[] = 
        {
            { "notehandle", "i", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument GetNote_args[] = 
        {
            { "notehandle", "i", true },
            { "name", "s", false },
            { "createtime", "t", false },
            { "createts", "t", false },
            { "edittime", "t", false },
            { "editts", "t", false },
            { "tags", "as", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument SetNote_args[] = 
        {
            { "notehandle", "i", true },
            { "name", "s", true },
            { "notetext", "s", true },
            { "tags", "as", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument DeleteNote_args[] = 
        {
            { "nodehandle", "i", true },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedArgument GetNotes_args[] = 
        {
            { "nodehandles", "ai", false },
            { 0, 0, 0 }
        };
        static ::DBus::IntrospectedMethod Notes_adaptor_methods[] = 
        {
            { "CreateNote", CreateNote_args },
            { "GetNote", GetNote_args },
            { "SetNote", SetNote_args },
            { "DeleteNote", DeleteNote_args },
            { "GetNotes", GetNotes_args },
            { 0, 0 }
        };
        static ::DBus::IntrospectedMethod Notes_adaptor_signals[] = 
        {
            { 0, 0 }
        };
        static ::DBus::IntrospectedProperty Notes_adaptor_properties[] = 
        {
            { 0, 0, 0, 0 }
        };
        static ::DBus::IntrospectedInterface Notes_adaptor_interface = 
        {
            "soma.recording.Notes",
            Notes_adaptor_methods,
            Notes_adaptor_signals,
            Notes_adaptor_properties
        };
        return &Notes_adaptor_interface;
    }

public:

    /* properties exposed by this interface, use
     * property() and property(value) to get and set a particular property
     */

public:

    /* methods exported by this interface,
     * you will have to implement them in your ObjectAdaptor
     */
    virtual int32_t CreateNote() = 0;
    virtual void GetNote(const int32_t& notehandle, std::string& name, uint64_t& createtime, uint64_t& createts, uint64_t& edittime, uint64_t& editts, std::vector< std::string >& tags) = 0;
    virtual void SetNote(const int32_t& notehandle, const std::string& name, const std::string& notetext, const std::vector< std::string >& tags) = 0;
    virtual void DeleteNote(const int32_t& nodehandle) = 0;
    virtual std::vector< int32_t > GetNotes() = 0;

public:

    /* signal emitters for this interface
     */

private:

    /* unmarshalers (to unpack the DBus message before calling the actual interface method)
     */
    ::DBus::Message _CreateNote_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argout1 = CreateNote();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
    ::DBus::Message _GetNote_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        std::string argout1;
        uint64_t argout2;
        uint64_t argout3;
        uint64_t argout4;
        uint64_t argout5;
        std::vector< std::string > argout6;
        GetNote(argin1, argout1, argout2, argout3, argout4, argout5, argout6);
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        wi << argout2;
        wi << argout3;
        wi << argout4;
        wi << argout5;
        wi << argout6;
        return reply;
    }
    ::DBus::Message _SetNote_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        std::string argin2; ri >> argin2;
        std::string argin3; ri >> argin3;
        std::vector< std::string > argin4; ri >> argin4;
        SetNote(argin1, argin2, argin3, argin4);
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _DeleteNote_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        int32_t argin1; ri >> argin1;
        DeleteNote(argin1);
        ::DBus::ReturnMessage reply(call);
        return reply;
    }
    ::DBus::Message _GetNotes_stub(const ::DBus::CallMessage &call)
    {
        ::DBus::MessageIter ri = call.reader();

        std::vector< int32_t > argout1 = GetNotes();
        ::DBus::ReturnMessage reply(call);
        ::DBus::MessageIter wi = reply.writer();
        wi << argout1;
        return reply;
    }
};

} } 
#endif//__dbusxx__dbusexperimentadaptor_h__ADAPTOR_MARSHAL_H
